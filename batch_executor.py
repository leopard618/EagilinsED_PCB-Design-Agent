"""
Batch Executor - Execute Multiple Commands Automatically

This module handles batch execution of placement commands:
- Queues multiple commands at once
- Generates Altium script for batch execution
- Tracks execution progress
"""
import json
import os
from typing import Dict, List, Any, Optional
from pathlib import Path
from datetime import datetime


class BatchExecutor:
    """
    Executes multiple Altium commands in batch.
    
    Instead of executing one command at a time (requiring user to run script each time),
    this generates a complete batch script that places all components at once.
    """
    
    def __init__(self, output_dir: str = "."):
        self.output_dir = Path(output_dir)
        self.commands: List[Dict[str, Any]] = []
        self.execution_log: List[Dict[str, Any]] = []
    
    def add_command(self, command: Dict[str, Any]):
        """Add a command to the batch"""
        self.commands.append(command)
    
    def add_commands(self, commands: List[Dict[str, Any]]):
        """Add multiple commands to the batch"""
        self.commands.extend(commands)
    
    def clear_commands(self):
        """Clear all pending commands"""
        self.commands = []
    
    def generate_batch_script(self) -> str:
        """
        Generate a DelphiScript that executes all placement commands.
        Returns the script content.
        """
        script_lines = [
            "{ Auto-generated batch placement script }",
            "{ Generated by EagilinsED Layout Generator }",
            f"{{ Timestamp: {datetime.now().isoformat()} }}",
            "",
            "Procedure ExecuteBatchPlacement;",
            "Var",
            "    Board : IPCB_Board;",
            "    Component : IPCB_Component;",
            "    Iterator : IPCB_BoardIterator;",
            "Begin",
            "    Board := PCBServer.GetCurrentPCBBoard;",
            "    If Board = Nil Then",
            "    Begin",
            "        ShowMessage('No PCB document open');",
            "        Exit;",
            "    End;",
            "",
            "    PCBServer.PreProcess;",
            "",
        ]
        
        # Group commands by type
        move_commands = [c for c in self.commands if c.get("command") == "move_component"]
        
        if move_commands:
            script_lines.append("    { === Component Placements === }")
            script_lines.append(f"    {{ Total: {len(move_commands)} components }}")
            script_lines.append("")
            
            for cmd in move_commands:
                params = cmd.get("parameters", {})
                designator = params.get("designator", "")
                x = params.get("x", 0)
                y = params.get("y", 0)
                rotation = params.get("rotation", 0)
                layer = params.get("layer", "Top")
                
                # Convert mm to mils (Altium internal units)
                x_mils = x * 39.3701
                y_mils = y * 39.3701
                
                script_lines.extend([
                    f"    {{ Place {designator} }}",
                    "    Iterator := Board.BoardIterator_Create;",
                    "    Iterator.AddFilter_ObjectSet(MkSet(eComponentObject));",
                    "    Iterator.AddFilter_LayerSet(AllLayers);",
                    "    Component := Iterator.FirstPCBObject;",
                    "    While Component <> Nil Do",
                    "    Begin",
                    f"        If Component.Name.Text = '{designator}' Then",
                    "        Begin",
                    f"            Component.X := MilsToCoord({x_mils:.2f});",
                    f"            Component.Y := MilsToCoord({y_mils:.2f});",
                    f"            Component.Rotation := {rotation};",
                    "            Component.GraphicallyInvalidate;",
                    "        End;",
                    "        Component := Iterator.NextPCBObject;",
                    "    End;",
                    "    Board.BoardIterator_Destroy(Iterator);",
                    "",
                ])
        
        script_lines.extend([
            "    PCBServer.PostProcess;",
            "    Board.GraphicallyInvalidate;",
            "",
            f"    ShowMessage('Batch placement complete. {len(move_commands)} components placed.');",
            "End;",
            "",
        ])
        
        return "\n".join(script_lines)
    
    def generate_placement_json(self) -> str:
        """
        Generate JSON file with all placements for the standard command executor.
        """
        placement_data = {
            "batch_id": datetime.now().strftime("%Y%m%d_%H%M%S"),
            "total_commands": len(self.commands),
            "commands": self.commands
        }
        return json.dumps(placement_data, indent=2)
    
    def save_batch_script(self, filename: str = "batch_placement.pas") -> Path:
        """Save the batch script to a file"""
        script_content = self.generate_batch_script()
        script_path = self.output_dir / "altium_scripts" / filename
        script_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(script_path, 'w') as f:
            f.write(script_content)
        
        return script_path
    
    def save_placement_json(self, filename: str = "batch_placements.json") -> Path:
        """Save placements to JSON file"""
        json_content = self.generate_placement_json()
        json_path = self.output_dir / filename
        
        with open(json_path, 'w') as f:
            f.write(json_content)
        
        return json_path
    
    def get_execution_summary(self) -> Dict[str, Any]:
        """Get summary of pending commands"""
        summary = {
            "total_commands": len(self.commands),
            "by_type": {},
            "by_block": {}
        }
        
        for cmd in self.commands:
            cmd_type = cmd.get("command", "unknown")
            block = cmd.get("block", "unknown")
            
            summary["by_type"][cmd_type] = summary["by_type"].get(cmd_type, 0) + 1
            summary["by_block"][block] = summary["by_block"].get(block, 0) + 1
        
        return summary


class AutoLayoutExecutor:
    """
    High-level executor for autonomous layout generation.
    Combines layout generation and batch execution.
    """
    
    def __init__(self, mcp_client=None):
        self.mcp_client = mcp_client
        self.batch_executor = BatchExecutor()
    
    def execute_layout(self, layout_commands: List[Dict], 
                      method: str = "batch_script") -> Dict[str, Any]:
        """
        Execute a complete layout.
        
        Args:
            layout_commands: List of placement commands
            method: Execution method
                - "batch_script": Generate a single script for all placements
                - "json_queue": Queue all commands to JSON for sequential execution
                - "immediate": Execute via MCP (if supported)
        
        Returns:
            Execution result with status and output paths
        """
        self.batch_executor.clear_commands()
        self.batch_executor.add_commands(layout_commands)
        
        result = {
            "success": True,
            "method": method,
            "command_count": len(layout_commands),
            "files": {}
        }
        
        if method == "batch_script":
            # Generate Altium batch script
            script_path = self.batch_executor.save_batch_script()
            result["files"]["script"] = str(script_path)
            result["message"] = f"Batch script generated: {script_path}"
            result["instructions"] = (
                "To execute the layout:\n"
                "1. Open your PCB in Altium Designer\n"
                "2. Go to File â†’ Run Script\n"
                "3. Select 'batch_placement.pas'\n"
                "4. Run 'ExecuteBatchPlacement'\n"
                "All components will be placed automatically."
            )
        
        elif method == "json_queue":
            # Save to JSON for command queue
            json_path = self.batch_executor.save_placement_json()
            result["files"]["json"] = str(json_path)
            result["message"] = f"Placements saved to: {json_path}"
        
        elif method == "immediate" and self.mcp_client:
            # Try to execute via MCP (for future COM support)
            result["message"] = "Immediate execution not yet supported"
            result["success"] = False
        
        result["summary"] = self.batch_executor.get_execution_summary()
        
        return result


def create_auto_layout_script(placements: List[Dict]) -> str:
    """
    Convenience function to create a batch script from placements.
    
    Args:
        placements: List of placement dicts with designator, x, y, rotation
        
    Returns:
        DelphiScript content
    """
    executor = BatchExecutor()
    
    for p in placements:
        executor.add_command({
            "command": "move_component",
            "parameters": {
                "designator": p.get("designator"),
                "x": p.get("x", 0),
                "y": p.get("y", 0),
                "rotation": p.get("rotation", 0),
                "layer": p.get("layer", "Top")
            }
        })
    
    return executor.generate_batch_script()

